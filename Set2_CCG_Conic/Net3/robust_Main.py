import networkx as nx;
import gurobipy as gp;
from gurobipy import GRB;
import sys;
import time;
from datetime import datetime;
import csv;
import pandas as pd;
import math;
import random;
import numpy;
from numpy import *  

from minCostFlow import*
from minCostFlow_Network import*
from RandomGamma import*

from robustNetwork import*
from sub0 import *
from sub1 import *


# Function to check the remaining time of the instance.
def checkTime(startTime, CCG_Time):
    
    currentTime = time.time();
    usedTime = currentTime - startTime;
    remainingTime = CCG_Time - usedTime;
    
    return remainingTime;


# cMax = -5;
# cMin = -8;

cMax = -10;
cMin = -30;

n_Nets = 1;
Budget = [14,12,10,8,6,4,2];
Rate = [1];

CCG_Time = 86400; # 24hs

sub_timeLimit = 7200;

now = datetime.now();


for n in range(1,n_Nets+1):
    
    network = "Net3.csv";
    
    G, s, t = robustNetwork (network);
    
    for rate in Rate:
        
        G1 = G.copy();
        
        for i in G1.successors(s):
                G1.edges[s,i]['capacity'] = math.floor(rate*G.edges[s,i]['capacity']);
        
    
        for budget in Budget:
            
            now_instance = datetime.now();
            startTime = time.time();
            
            Traffickers = [];
            Bottoms = [];
            Victims = [];
            
            for i,j in G1.edges:
                if G1.edges[i,j]['trafficker'] == 1:
                    Traffickers.append(j);
                elif G1.edges[i,j]['bottom'] == 1:
                    Bottoms.append(j);
                elif G1.edges[i,j]['victim'] == 1:
                    Victims.append(j);
            
            #####################  Variables & Parameters #####################
            
            LB = 0; # LB for the C&CG obtained from the Master's obj.
            
            UB = 10e8;  # Smallest UB obtained from the Sub
            UB_temp = 10e8; # Temporary UB obtained from Sub 
            
            ub0 = 10e8; # UB obtained from Sub0 
            ub1 = 10e8; # UB obtained from Sub1
            
            lb0 = 0; # LB from Sub0 (obj. value)
            lb1 = 0; # LB from Sub1 (obj. value)
            lb = 0;
            
            Gamma = {}; # Best interdiction (associated with the UB)
            Gamma_temp = {}; # New interdiction generated by the Master after each solve
            
            C = {}; # Set of cost vectors generated by the C&CG
            c0 = {}; # Cost vector generated by Sub0
            c1 = {}; # Cost vector generated by Sub1
            
            gap0 = 0; # MIP gap from sub0;
            gap1 = 0; # MIP gap from sub1;
            Gap = 0; # MIP gap from subproblem associated with best UB
            Gap_temp = 0; # MIP gap from subproblem (Sub0 or Sub1 depending on their ub)
            
            eps = 0.1; # Optimality tolerance for C&CG
            
            it=0; # Initialization
            
            print('\n\nInstance: %s, Budget %g' %(network, budget));
            print('Instance executed on %s \n' %now_instance.strftime("%c"));
            

            # ~~~~ Generate Initial Gamma ~~~~~~~~~~~~~~~~~~~~~~~~~
            
            costVector = {};
            for i,j in G.edges:
                if j == t:
                    costVector[i,j] = random.randint(cMin, cMax-3);
                    if i == s:
                        costVector[i,j] = cMax;
                else:
                    costVector[i,j] = 0;
            
            
            G_minCost = minCostFlow_Network (G1, s, t, costVector);           
            
            Gamma = minCostFlow1 (G_minCost, s, t, budget);
            
            
            # time_gamma0 = round(time.time() - time1, 2);
            # print('\n\nTime initial gamma: %g secs\n\n' %time_gamma0);
            
            
            print('\n\n------ Initialization (Iteration %d) -------' %it)   
            
            print('\nInitial Interdiction:')
            for i,j in G_minCost.edges:
                if Gamma[i,j] > 0.001:
                        print('(%d,%d)' %(i,j));
            # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
            
            
            c0, lb0, ub0, gap0 = sub0 (G, s, t, budget, Gamma, cMin, cMax, it, sub_timeLimit);
            c1, lb1, ub1, gap1 = sub1 (G, s, t, budget, Gamma, cMin, cMax, it, sub_timeLimit);
            
            
            print('\nub (Sub0): %g' %ub0);
            print('ub (Sub1): %g\n' %ub1);
            
            C[it] = {}; # New cost vector generated by the subproblem
            
            if ub0 > ub1:
                C[it] = c0;
                UB = ub0;
                Gap = gap0;
                lb = lb0;
            else:
                C[it] = c1;
                UB = ub1;
                Gap = gap1;
                lb = lb1;
            
            # print('\nCost Vector:')
            # for i,j in G1.edges:
            #     if C[it][i,j] != 0:
            #         print('c[%d,%d] = %g' %(i,j,C[it][i,j]));
                        
            master = gp.Model('master');
            
            gamma = master.addVars(G1.edges, vtype=GRB.BINARY, name='gamma');
            eta = master.addVar(vtype=GRB.CONTINUOUS, lb = 0, ub = GRB.INFINITY, name='eta');
            # eta = master.addVar(vtype=GRB.INTEGER, lb = 0, ub = GRB.INFINITY, name='eta');
            
            x = {};
            alpha = {};
            theta = {};
            
            
            x[it] = master.addVars(G1.edges, vtype=GRB.CONTINUOUS, lb = 0, ub = GRB.INFINITY, name='flow');
            alpha[it] = master.addVars(G1.nodes, vtype=GRB.CONTINUOUS, lb = -GRB.INFINITY, ub = GRB.INFINITY, name='alpha');
            theta[it] = master.addVars(G1.edges, vtype=GRB.CONTINUOUS, lb = -GRB.INFINITY, ub = 0, name='theta');
            
            
            master.addConstr(gp.quicksum(G1.edges[i,j]['int_cost']*gamma[i,j] for i,j in G1.edges) <= budget);
            
            master.addConstr(eta >= gp.quicksum(x[it][i,j]*G1.edges[i,j]['special'] for i,j in G1.edges));
            
            master.addConstrs(gp.quicksum(x[it][i,j] for j in G1.successors(i)) 
                             - gp.quicksum(x[it][j,i] for j in G1.predecessors(i)) 
                             == G1.nodes[i]['demand'] for i in G1.nodes);
        
            for i,j in G.edges:
                master.addConstr(x[it][i,j] <= G1.edges[i,j]['capacity']*(1-gamma[i,j]));
                master.addConstr(alpha[it][i] - alpha[it][j] + theta[it][i,j] <= C[it][i,j]);
            
            master.addConstr( gp.quicksum(G1.nodes[i]['demand']*alpha[it][i] for i in G1.nodes)
                             + gp.quicksum(G1.edges[i,j]['capacity']*(1 - gamma[i,j])*theta[it][i,j] for i,j in G1.edges)
                             - gp.quicksum(C[it][i,j]*x[it][i,j] for i,j in G1.edges) >= 0);
            
            
            master.setObjective(eta, GRB.MINIMIZE);
            
            
            print('\n--- Solving Master problem ---\n')
            
            remainingTime = checkTime(startTime, CCG_Time);
            print('\nRemaining Time %g\n' %remainingTime);
            
            file = 'LogFile_Master_B'+str(budget)+'.txt'
                
            master.setParam("NonConvex", 2);
            
            master.setParam("OutputFlag", 1);
            master.setParam("LogFile", file);
            master.setParam("LogToConsole", 0);
            master.setParam("MIPFocus", 3);
            master.setParam("NumericFocus", 3);
            master.setParam("Cuts", 3);
            master.setParam("TimeLimit", remainingTime);
            master.optimize();
                       
            if master.status == 9:
                print("Time Limit Reached!")
                
            LB = master.ObjVal;
            
            print('\nLB (Master): %g' %LB);
            print('UB (Sub): %g\n' %UB);

            for i,j in G1.edges:
                Gamma_temp[i,j] = gamma[i,j].x;
            
            print('\nInterdiction:')
            for i,j in G1.edges:
                if Gamma_temp[i,j] >= 0.0001:
                    print('(%d,%d)' %(i,j));
    
            
            
            while UB - LB > eps:
                
                it += 1;
                
                print('\n\n------ Iteration %d -------' %it)
                
                remainingTime = checkTime(startTime, CCG_Time);
                
                if remainingTime <= 0:
                    print('\nNo time left. Terminate.\n');
                    break;
                
                c0, lb0, ub0, gap0 = sub0 (G, s, t, budget, Gamma_temp, cMin, cMax, it, min(remainingTime, sub_timeLimit));
                c1, lb1, ub1, gap1 = sub1 (G, s, t, budget, Gamma_temp, cMin, cMax, it, min(remainingTime, sub_timeLimit));
                
                
                print('\nub (Sub0): %g' %ub0);
                print('ub (Sub1): %g\n' %ub1);
                
                # C[it] = {};
                
                if ub0 > ub1:
                    # C[it] = c0;
                    C_temp = c0;
                    UB_temp = ub0;
                    Gap = gap0;
                    lb = lb0;
                else:
                    # C[it] = c1;
                    C_temp = c1;
                    UB_temp = ub1;
                    Gap = gap1;
                    lb = lb1;
                
                if UB_temp <= UB:
                    UB = UB_temp;
                    Gamma = Gamma_temp;
                
                
                
                # Checking whether Subproblem generated a repeated cost vector
                for k in range(it):
                    if C[k] == C_temp:
                        print('\nCurrent c is equal to c[%d]!' %k);
                        
                        if Gap == 0:
                            print('No Gap! Break!');
                            break;
                        else:
                            print('Positive Gap from Sub!');
                            print('Use remaining time trying to solve Sub to optimality!\n');
                            
                            remainingTime = checkTime(startTime, CCG_Time);
                            
                            print('\nRemaining Time %g\n' %remainingTime);
                            
                            if remainingTime <= 0:
                                print('\nNo time left. Terminate.');
                                break;
                            
                            c0, lb0, ub0, gap0 = sub0 (G, s, t, budget, Gamma, cMin, cMax, it, remainingTime);
    
                            c1, lb1, ub1, gap1 = sub1 (G, s, t, budget, Gamma, cMin, cMax, it, remainingTime);
                            
                            print('\nub (Sub0): %g' %ub0);
                            print('ub (Sub1): %g\n' %ub1);
                        
                        
                            if ub0 > ub1:
                                C_temp = c0;
                                UB_temp = ub0;
                                Gap = gap0;
                                lb = lb0;
                            else:
                                C_temp = c1;
                                UB_temp = ub1;
                                Gap = gap1;
                                lb = lb1;
                            
                            if UB_temp <= UB:
                                UB = UB_temp;
                        
                            
                            remainingTime = checkTime(startTime, CCG_Time);
                            print('\nRemaining Time %g\n' %remainingTime);
                            
                            if remainingTime <= 0:
                                print('\nNo time left. Terminate.');
                                print('\nLB (Master): %g' %LB);
                                print('UB (Sub): %g\n' %UB);
                                break;
                    
                C[it] = {};
                C[it] = C_temp;
                        
                remainingTime = checkTime(startTime, CCG_Time);
                if remainingTime <= 0:
                    break;
                
                x[it] = master.addVars(G1.edges, vtype=GRB.CONTINUOUS, lb = 0, ub = GRB.INFINITY, name='flow');
                alpha[it] = master.addVars(G1.nodes, vtype=GRB.CONTINUOUS, lb = -GRB.INFINITY, ub = GRB.INFINITY, name='alpha');
                theta[it] = master.addVars(G1.edges, vtype=GRB.CONTINUOUS, lb = -GRB.INFINITY, ub = 0, name='theta');
                
                
                master.addConstr(gp.quicksum(G1.edges[i,j]['int_cost']*gamma[i,j] for i,j in G1.edges) <= budget);
                
                master.addConstr(eta >= gp.quicksum(x[it][i,j]*G1.edges[i,j]['special'] for i,j in G1.edges));
                
                master.addConstrs(gp.quicksum(x[it][i,j] for j in G1.successors(i)) 
                                 - gp.quicksum(x[it][j,i] for j in G1.predecessors(i)) 
                                 == G1.nodes[i]['demand'] for i in G1.nodes);
            
                for i,j in G.edges:
                    master.addConstr(x[it][i,j] <= G1.edges[i,j]['capacity']*(1-gamma[i,j]));
                    master.addConstr(alpha[it][i] - alpha[it][j] + theta[it][i,j] <= C[it][i,j]);
                
                master.addConstr( gp.quicksum(G1.nodes[i]['demand']*alpha[it][i] for i in G1.nodes)
                                 + gp.quicksum(G1.edges[i,j]['capacity']*(1 - gamma[i,j])*theta[it][i,j] for i,j in G1.edges)
                                 - gp.quicksum(C[it][i,j]*x[it][i,j] for i,j in G1.edges) >= 0);
                
                
                master.setObjective(eta, GRB.MINIMIZE);
                
                
                print('\n--- Solving Master problem ---\n')
                
                file = 'LogFile_Master_B'+str(budget)+'.txt';
                    
                master.setParam("NonConvex", 2);
                
                master.setParam("OutputFlag", 1);
                master.setParam("LogFile", file);
                master.setParam("LogToConsole", 0);
                master.setParam("MIPFocus", 3);
                master.setParam("Cuts", 3);
                master.setParam("TimeLimit", remainingTime);
                master.optimize();
                           
                if master.status == 9:
                    print("Time Limit Reached!")
                    
                LB = master.ObjVal;
                
                print('\nLB (Master): %g' %LB);
                print('UB (Sub): %g\n' %UB);

                for i,j in G1.edges:
                    Gamma_temp[i,j] = gamma[i,j].x;
                
                print('\nInterdiction:')
                for i,j in G1.edges:
                    if Gamma_temp[i,j] >= 0.0001:
                        print('(%d,%d)' %(i,j));
               
                
            end = time.time();
            runTime = round(end-startTime, 2);
                
            print('\nRunning Time: %g secs' %runTime);
                 
            fileResults = 'Results_Net' + str(len(Traffickers)) + '_B' +str(budget)+'.txt';
            
            with open(fileResults, "w") as file:
                file.write('Instance executed at: %s \n' %now.strftime("%c"));
                
                file.write('\nRuntime: %g\n' %runTime);
                
                file.write('\nLB (Master): %g' %LB);
                file.write('\nUB (Sub): %g' %UB);
                file.write('\nlb (Sub): %g\n' %lb);
                
                if UB - LB > 0:
                    if LB != 0:
                        Gap_CCG = 100*round(abs(UB - LB)/LB,2);
                    else:
                        Gap_CCG = 10e15;
                else:
                    Gap_CCG = 0;
                    
                file.write('\nGap (C&CG): %g%s\n' %(Gap_CCG,str(chr(37))));
                
                gap = 100*round(Gap,2);
                file.write('\nGap (sub): %g%s\n' %(gap,str(chr(37))));
                
                file.write('\nInterdiction Vectors:\n');
                for i,j in G1.edges:
                    if Gamma[i,j] > 0.0001:
                        file.write('(%d,%d) ' %(i,j));
                file.write('\n\n')
                
                file.write('Cost Vectors\n')
                for k in C.keys():
                    file.write('Iteration %d:\n' %k);
                    for i,j in G1.edges:
                        file.write('%g ' %C[k][i,j]);
                    file.write('\n\n');
            
            
            
            
                
            
            
            
            
            
